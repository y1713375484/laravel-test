/*
 Navicat MySQL Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50726
 Source Host           : localhost:3306
 Source Schema         : laravel-test

 Target Server Type    : MySQL
 Target Server Version : 50726
 File Encoding         : 65001

 Date: 23/01/2025 00:02:46
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blogs
-- ----------------------------
DROP TABLE IF EXISTS `blogs`;
CREATE TABLE `blogs`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `html_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `author` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '作者',
  `time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blogs
-- ----------------------------
INSERT INTO `blogs` VALUES (3, '这篇博客有图片哦，我重新修改了', '我是这篇博客的描述222', '刚吃过早饭', '<p>刚吃过早饭</p><p><img src=\"/upload/1737520066_test4.jpg\" alt=\"\" data-href=\"\" style=\"\"/></p>', 'yzh', '2025-01-22 12:28:00');
INSERT INTO `blogs` VALUES (6, 'golang的gin框架使用方式', 'gin', '这是golang的logo\n\ngin框架是一个golang的web框架\n安装方法：\n$ go get -u github.com/gin-gonic/gin\n使用方法：\npackage main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n	r := gin.Default()\n	r.GET(\"/ping\", func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			\"message\": \"pong\",\n		})\n	})\n	r.Run() // 监听并在 0.0.0.0:8080 上启动服务\n}', '<p style=\"text-align: center;\"><img src=\"/upload/1737558535_v2-fffa097ba5829850a3611aa071e2aadf_720w.png\" alt=\"\" data-href=\"\" style=\"width: 100%;\">这是golang的logo</p><p style=\"text-align: center;\"><br></p><p style=\"text-align: left;\">gin框架是一个golang的web框架</p><p style=\"text-align: left;\">安装方法：</p><pre><code >$ go get -u github.com/gin-gonic/gin</code></pre><p>使用方法：</p><pre style=\"text-align: start;\"><code class=\"language-go\">package main\n\nimport \"github.com/gin-gonic/gin\"\n\nfunc main() {\n	r := gin.Default()\n	r.GET(\"/ping\", func(c *gin.Context) {\n		c.JSON(200, gin.H{\n			\"message\": \"pong\",\n		})\n	})\n	r.Run() // 监听并在 0.0.0.0:8080 上启动服务\n}</code></pre><p><br></p>', 'admin', '2025-02-09 23:08:00');
INSERT INTO `blogs` VALUES (7, 'laravel介绍', 'laravel', 'Laravel 8\nLaravel 8 通过引入 Laravel Jetstream，模型工厂类，迁移压缩，队列批处理，改善速率限制， 队列改进，动态 Blade 组件，Tailwind 分页视图， 时间测试助手，artisan serve 的改进，事件监听器的改进，以及各种其他错误修复和可用性改进，对 Laravel 7.x 继续进行了改善。\n\nLaravel Jetstream\nLaravel Jetstream 由 Taylor Otwell 撰写。\n\nLaravel Jetstream 是为 Laravel 设计的精美的应用程序脚手架。Jetstream 为你的下一个项目提供了完美的起点，包括登录、注册、电子邮件验证、双因子认证、会话管理、通过 Laravel Sanctum 提供的 API 支持以及可选的团队管理。Laravel Jetstream 替代并改进了可用于早期版本的 Laravel 的旧式身份验证 UI 支架。\n\nJetstream 是使用 Tailwind CSS 设计的，你可以选择 Livewire 或 Inertia 脚手架。\n\n模型工厂类\n模型工厂类由泰勒・奥特威尔 Taylor Otwell 贡献。\nEloquent 模型工厂 已完全重写为基于类的工厂，并有完美的关联支持。 例如 Laravel 中的 UserFactory 是这样写的：\n<?php\r\n\r\nnamespace Database\\Factories;\r\n\r\nuse App\\Models\\User;\r\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\nuse Illuminate\\Support\\Str;\r\n\r\nclass UserFactory extends Factory\r\n{\r\n    /**\r\n     * 工厂对应模型的名称。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $model = User::class;\r\n\r\n    /**\r\n     * 定义模型的默认状态。\r\n     *\r\n     * @return array\r\n     */\r\n    public function definition()\r\n    {\r\n        return [\r\n            \'name\' => $this->faker->name,\r\n            \'email\' => $this->faker->unique()->safeEmail,\r\n            \'email_verified_at\' => now(),\r\n            \'password\' => \'$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi\', // password\r\n            \'remember_token\' => Str::random(10),\r\n        ];\r\n    }\r\n}', '<p>Laravel 8</p><p>Laravel 8 通过引入 Laravel Jetstream，模型工厂类，迁移压缩，队列批处理，改善速率限制， 队列改进，动态 Blade 组件，Tailwind 分页视图， 时间测试助手，artisan serve 的改进，事件监听器的改进，以及各种其他错误修复和可用性改进，对 Laravel 7.x 继续进行了改善。</p><p><br></p><p>Laravel Jetstream</p><p>Laravel Jetstream 由 Taylor Otwell 撰写。</p><p><br></p><p>Laravel Jetstream 是为 Laravel 设计的精美的应用程序脚手架。Jetstream 为你的下一个项目提供了完美的起点，包括登录、注册、电子邮件验证、双因子认证、会话管理、通过 Laravel Sanctum 提供的 API 支持以及可选的团队管理。Laravel Jetstream 替代并改进了可用于早期版本的 Laravel 的旧式身份验证 UI 支架。</p><p><br></p><p>Jetstream 是使用 Tailwind CSS 设计的，你可以选择 Livewire 或 Inertia 脚手架。</p><p><br></p><p>模型工厂类</p><p>模型工厂类由泰勒・奥特威尔 Taylor Otwell 贡献。</p><p>Eloquent 模型工厂 已完全重写为基于类的工厂，并有完美的关联支持。 例如 Laravel 中的 UserFactory 是这样写的：</p><pre><code >&lt;?php\r\n\r\nnamespace Database\\Factories;\r\n\r\nuse App\\Models\\User;\r\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\r\nuse Illuminate\\Support\\Str;\r\n\r\nclass UserFactory extends Factory\r\n{\r\n    /**\r\n     * 工厂对应模型的名称。\r\n     *\r\n     * @var string\r\n     */\r\n    protected $model = User::class;\r\n\r\n    /**\r\n     * 定义模型的默认状态。\r\n     *\r\n     * @return array\r\n     */\r\n    public function definition()\r\n    {\r\n        return [\r\n            \'name\' =&gt; $this-&gt;faker-&gt;name,\r\n            \'email\' =&gt; $this-&gt;faker-&gt;unique()-&gt;safeEmail,\r\n            \'email_verified_at\' =&gt; now(),\r\n            \'password\' =&gt; \'$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi\', // password\r\n            \'remember_token\' =&gt; Str::random(10),\r\n        ];\r\n    }\r\n}</code></pre><p><br></p>', 'admin', '2025-01-22 23:29:00');
INSERT INTO `blogs` VALUES (8, 'PHP高性能框架webman介绍', 'webman', '序言\nWorkerman，高性能PHP应用容器\nWorkerman是什么？\nWorkerman是一款纯PHP开发的开源高性能的PHP 应用容器。\nWorkerman不是重复造轮子，它不是一个MVC框架，而是一个更底层更通用的服务框架，你可以用它开发tcp代理、梯子代理、做游戏服务器、邮件服务器、ftp服务器、甚至开发一个php版本的redis、php版本的数据库、php版本的nginx、php版本的php-fpm等等。Workerman可以说是PHP领域的一次创新，让开发者彻底摆脱了PHP只能做WEB的束缚。\n实际上Workerman类似一个PHP版本的nginx，核心也是多进程+Epoll+非阻塞IO。Workerman每个进程能维持上万并发连接。由于本身常驻内存，不依赖Apache、nginx、php-fpm这些容器，拥有超高的性能。同时支持TCP、UDP、UNIXSOCKET，支持长连接，支持Websocket、HTTP、WSS、HTTPS等通讯协议以及各种自定义协议。拥有定时器、异步socket客户端、异步Redis、异步Http、异步消息队列等众多高性能组件。\nWorkerman的一些应用方向\nWorkerman不同于传统MVC框架，Workerman不仅可以用于Web开发，同时还有更广阔的应用领域，例如即时通讯类、物联网、游戏、服务治理、其它服务器或者中间件，这无疑大大提高了PHP开发者的视野。目前这些领域的PHP开发者奇缺，如果想在PHP领域有自己的技术优势，不满足于每天的增删改查工作，或者想向架构师方向或者技术大牛的方向发展，Workerman都是非常值得学习的框架。建议开发者不仅会用，而且能基于Workerman开发出属于自己的开源项目，提升技能增加自己的影响力，比如Beanbun多进程网络爬虫框架就是一个很好的例子，刚刚上线不久就获得众多好评。\nWorkerman的一些应用方向如下：\n1、即时通讯类\n例如网页即时聊天、即时消息推送、微信小程序、手机app消息推送、PC软件消息推送等等\n[示例 workerman-chat聊天室 、 web消息推送 、 小蝌蚪聊天室]\n2、物联网类\n例如Workerman与打印机通讯、与单片机通讯、智能手环、智能家居、共享单车等等。\n[客户案例如 易联云、易泊时代等]\n3、游戏服务器类\n例如棋牌游戏、MMORPG游戏等等。[示例 browserquest-php]\n4、HTTP服务\n例如 写高性能HTTP接口、高性能网站。如果想要做HTTP相关的服务或者站点强烈推荐 webman\n5、SOA服务化\n利用Workerman将现有业务不同功能单元封装起来，以服务的形式对外提供统一的接口，达到系统松耦合、易维护、高可用、易伸缩。[示例 workerman-json-rpc、 workerman-thrift]\n6、其它服务器软件\n例如 GatewayWorker，PHPSocket.IO，http代理，sock5代理，分布式通讯组件，分布式变量共享组件，消息队列、DNS服务器、WebServer、CDN服务器、FTP服务器等等\n7、组件\n例如异步redis，异步http客户端，物联网mqtt客户端，消息队列 workerman/redis-queue 、 workerman/stomp、workerman/rabbitmq ，文件监控组件，还有很多第三方开发的组件框架等等\n显然传统的mvc框架很难实现以上的功能，所以也就是workerman诞生的原因。\n-----------------------------------------------------------------------------------------------------------------webman可以实现异步、并行的http客户端，目前PHP框架中为数不多的高性能框架。\n异步客户端\nuse Workerman\\Worker;\n\nrequire_once __DIR__ . \'/vendor/autoload.php\';\n\n$worker = new Worker();\n$worker->onWorkerStart = function () {\n    $http = new Workerman\\Http\\Client();\n\n    $http->get(\'https://example.com/\', function ($response) {\n        var_dump($response->getStatusCode());\n        echo $response->getBody();\n    }, function ($exception) {\n        echo $exception;\n    });\n\n    $http->post(\'https://example.com/\', [\'key1\' => \'value1\', \'key2\' => \'value2\'], function ($response) {\n        var_dump($response->getStatusCode());\n        echo $response->getBody();\n    }, function ($exception) {\n        echo $exception;\n    });\n\n    $http->request(\'https://example.com/\', [\n        \'method\' => \'POST\',\n        \'version\' => \'1.1\',\n        \'headers\' => [\'Connection\' => \'keep-alive\'],\n        \'data\' => [\'key1\' => \'value1\', \'key2\' => \'value2\'],\n        \'success\' => function ($response) {\n            echo $response->getBody();\n        },\n        \'error\' => function ($exception) {\n            echo $exception;\n        }\n    ]);\n};\nWorker::runAll();\n协程客户端\nuse Workerman\\Worker;\n\nrequire_once __DIR__ . \'/vendor/autoload.php\';\n\n$worker = new Worker();\n$worker->onWorkerStart = function () {\n    $http = new Workerman\\Http\\Client();\n\n    $response = $http->get(\'https://example.com/\');\n    var_dump($response->getStatusCode());\n    echo $response->getBody();\n\n    $response = $http->post(\'https://example.com/\', [\'key1\' => \'value1\', \'key2\' => \'value2\']);\n    var_dump($response->getStatusCode());\n    echo $response->getBody();\n\n    $response = $http->request(\'https://example.com/\', [\n        \'method\' => \'POST\',\n        \'version\' => \'1.1\',\n        \'headers\' => [\'Connection\' => \'keep-alive\'],\n        \'data\' => [\'key1\' => \'value1\', \'key2\' => \'value2\'],\n    ]);\n    echo $response->getBody();\n};\nWorker::runAll();\n协程的好处就是可以避免回调地狱，再来看一下golang的协程客户端\npackage main\n\nimport (\n	\"fmt\"\n	\"io/ioutil\"\n	\"net/http\"\n	\"sync\"\n)\n\nfunc fetchURL(url string, wg *sync.WaitGroup) {\n	defer wg.Done()\n\n	resp, err := http.Get(url)\n	if err != nil {\n		fmt.Printf(\"Error fetching %s: %v\\n\", url, err)\n		return\n	}\n	defer resp.Body.Close()\n\n	body, err := ioutil.ReadAll(resp.Body)\n	if err != nil {\n		fmt.Printf(\"Error reading response body from %s: %v\\n\", url, err)\n		return\n	}\n\n	fmt.Printf(\"Response from %s: %d bytes\\n\", url, len(body))\n}\n\nfunc main() {\n	urls := []string{\n		\"https://www.example.com\",\n		\"https://www.google.com\",\n		\"https://www.github.com\",\n	}\n\n	var wg sync.WaitGroup\n\n	for _, url := range urls {\n		wg.Add(1)\n		go fetchURL(url, &wg)\n	}\n\n	wg.Wait()\n	fmt.Println(\"All requests completed.\")\n}', '<h1 style=\"text-align: left;\"><a href=\"https://www.workerman.net/doc/workerman/README.html#%E5%BA%8F%E8%A8%80\" target=\"\">序言</a></h1><p style=\"text-align: left;\"><strong>Workerman，高性能PHP应用容器</strong></p><h2 style=\"text-align: left;\"><a href=\"https://www.workerman.net/doc/workerman/README.html#Workerman%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\" target=\"\">Workerman是什么？</a></h2><p style=\"text-align: left;\">Workerman是一款纯PHP开发的开源高性能的PHP 应用容器。</p><p style=\"text-align: left;\">Workerman不是重复造轮子，它不是一个MVC框架，而是一个更底层更通用的服务框架，你可以用它开发tcp代理、梯子代理、做游戏服务器、邮件服务器、ftp服务器、甚至开发一个php版本的redis、php版本的数据库、php版本的nginx、php版本的php-fpm等等。Workerman可以说是PHP领域的一次创新，让开发者彻底摆脱了PHP只能做WEB的束缚。</p><p style=\"text-align: left;\">实际上Workerman类似一个PHP版本的nginx，核心也是多进程+Epoll+非阻塞IO。Workerman每个进程能维持上万并发连接。由于本身常驻内存，不依赖Apache、nginx、php-fpm这些容器，拥有超高的性能。同时支持TCP、UDP、UNIXSOCKET，支持长连接，支持Websocket、HTTP、WSS、HTTPS等通讯协议以及各种自定义协议。拥有定时器、异步socket客户端、异步Redis、异步Http、异步消息队列等众多高性能组件。</p><h2 style=\"text-align: left;\"><a href=\"https://www.workerman.net/doc/workerman/README.html#Workerman%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91\" target=\"\">Workerman的一些应用方向</a></h2><p style=\"text-align: left;\">Workerman不同于传统MVC框架，Workerman不仅可以用于Web开发，同时还有更广阔的应用领域，例如即时通讯类、物联网、游戏、服务治理、其它服务器或者中间件，这无疑大大提高了PHP开发者的视野。目前这些领域的PHP开发者奇缺，如果想在PHP领域有自己的技术优势，不满足于每天的增删改查工作，或者想向架构师方向或者技术大牛的方向发展，Workerman都是非常值得学习的框架。建议开发者不仅会用，而且能基于Workerman开发出属于自己的开源项目，提升技能增加自己的影响力，比如<a href=\"https://github.com/kiddyuchina/Beanbun\" target=\"_blank\">Beanbun多进程网络爬虫框架</a>就是一个很好的例子，刚刚上线不久就获得众多好评。</p><p style=\"text-align: left;\">Workerman的一些应用方向如下：</p><p style=\"text-align: left;\">1、即时通讯类<br>例如网页即时聊天、即时消息推送、微信小程序、手机app消息推送、PC软件消息推送等等<br>[<a href=\"https://www.workerman.net/workerman-chat\" target=\"\">示例 workerman-chat聊天室</a> 、 <a href=\"https://www.workerman.net/web-sender\" target=\"\">web消息推送</a> 、 <a href=\"https://www.workerman.net/workerman-todpole\" target=\"\">小蝌蚪聊天室</a>]</p><p style=\"text-align: left;\">2、物联网类<br>例如Workerman与打印机通讯、与单片机通讯、智能手环、智能家居、共享单车等等。<br>[客户案例如 易联云、易泊时代等]</p><p style=\"text-align: left;\">3、游戏服务器类<br>例如棋牌游戏、MMORPG游戏等等。[<a href=\"https://www.workerman.net/browserquest\" target=\"\">示例 browserquest-php</a>]</p><p style=\"text-align: left;\">4、HTTP服务<br>例如 写高性能HTTP接口、高性能网站。如果想要做HTTP相关的服务或者站点强烈推荐 <a href=\"https://github.com/walkor/webman\" target=\"_blank\">webman</a></p><p style=\"text-align: left;\">5、SOA服务化<br>利用Workerman将现有业务不同功能单元封装起来，以服务的形式对外提供统一的接口，达到系统松耦合、易维护、高可用、易伸缩。[<a href=\"https://github.com/walkor/workerman-jsonrpc\" target=\"_blank\">示例 workerman-json-rpc</a>、 <a href=\"https://github.com/walkor/workerman-thrift\" target=\"_blank\">workerman-thrift</a>]</p><p style=\"text-align: left;\">6、其它服务器软件<br>例如 <a href=\"https://www.workerman.net/doc/gateway-worker\" target=\"\">GatewayWorker</a>，<a href=\"https://www.workerman.net/phpsocket_io\" target=\"\">PHPSocket.IO</a>，<a href=\"https://github.com/walkor/php-http-proxy\" target=\"_blank\">http代理</a>，<a href=\"https://github.com/walkor/php-socks5\" target=\"_blank\">sock5代理</a>，<a href=\"https://github.com/walkor/Channel\" target=\"_blank\">分布式通讯组件</a>，<a href=\"https://github.com/walkor/GlobalData\" target=\"_blank\">分布式变量共享组件</a>，<a href=\"https://github.com/walkor/workerman-queue\" target=\"_blank\">消息队列</a>、DNS服务器、WebServer、CDN服务器、FTP服务器等等</p><p style=\"text-align: left;\">7、组件<br>例如<a href=\"https://www.workerman.net/doc/workerman/components/workerman-redis.html\" target=\"\">异步redis</a>，<a href=\"https://www.workerman.net/doc/workerman/components/workerman-http-client.html\" target=\"\">异步http客户端</a>，<a href=\"https://www.workerman.net/doc/workerman/components/workerman-mqtt.html\" target=\"\">物联网mqtt客户端</a>，消息队列 <a href=\"https://www.workerman.net/doc/workerman/components/workerman-redis-queue.html\" target=\"\">workerman/redis-queue</a> 、 <a href=\"https://www.workerman.net/doc/workerman/components/workerman-stomp.html\" target=\"\">workerman/stomp</a>、<a href=\"https://www.workerman.net/doc/workerman/components/workerman-rabbitmq.html\" target=\"\">workerman/rabbitmq</a> ，<a href=\"https://www.workerman.net/doc/workerman/components/file-monitor.html\" target=\"\">文件监控组件</a>，还有很多第三方开发的组件框架等等</p><p style=\"text-align: left;\">显然传统的mvc框架很难实现以上的功能，所以也就是workerman诞生的原因。</p><p style=\"text-align: left;\">-----------------------------------------------------------------------------------------------------------------webman可以实现异步、并行的http客户端，目前PHP框架中为数不多的高性能框架。</p><h2 style=\"text-align: left;\">异步客户端</h2><pre><code >use Workerman\\Worker;\n\nrequire_once __DIR__ . \'/vendor/autoload.php\';\n\n$worker = new Worker();\n$worker-&gt;onWorkerStart = function () {\n    $http = new Workerman\\Http\\Client();\n\n    $http-&gt;get(\'https://example.com/\', function ($response) {\n        var_dump($response-&gt;getStatusCode());\n        echo $response-&gt;getBody();\n    }, function ($exception) {\n        echo $exception;\n    });\n\n    $http-&gt;post(\'https://example.com/\', [\'key1\' =&gt; \'value1\', \'key2\' =&gt; \'value2\'], function ($response) {\n        var_dump($response-&gt;getStatusCode());\n        echo $response-&gt;getBody();\n    }, function ($exception) {\n        echo $exception;\n    });\n\n    $http-&gt;request(\'https://example.com/\', [\n        \'method\' =&gt; \'POST\',\n        \'version\' =&gt; \'1.1\',\n        \'headers\' =&gt; [\'Connection\' =&gt; \'keep-alive\'],\n        \'data\' =&gt; [\'key1\' =&gt; \'value1\', \'key2\' =&gt; \'value2\'],\n        \'success\' =&gt; function ($response) {\n            echo $response-&gt;getBody();\n        },\n        \'error\' =&gt; function ($exception) {\n            echo $exception;\n        }\n    ]);\n};\nWorker::runAll();</code></pre><h2 style=\"text-align: left;\">协程客户端</h2><pre><code >use Workerman\\Worker;\n\nrequire_once __DIR__ . \'/vendor/autoload.php\';\n\n$worker = new Worker();\n$worker-&gt;onWorkerStart = function () {\n    $http = new Workerman\\Http\\Client();\n\n    $response = $http-&gt;get(\'https://example.com/\');\n    var_dump($response-&gt;getStatusCode());\n    echo $response-&gt;getBody();\n\n    $response = $http-&gt;post(\'https://example.com/\', [\'key1\' =&gt; \'value1\', \'key2\' =&gt; \'value2\']);\n    var_dump($response-&gt;getStatusCode());\n    echo $response-&gt;getBody();\n\n    $response = $http-&gt;request(\'https://example.com/\', [\n        \'method\' =&gt; \'POST\',\n        \'version\' =&gt; \'1.1\',\n        \'headers\' =&gt; [\'Connection\' =&gt; \'keep-alive\'],\n        \'data\' =&gt; [\'key1\' =&gt; \'value1\', \'key2\' =&gt; \'value2\'],\n    ]);\n    echo $response-&gt;getBody();\n};\nWorker::runAll();</code></pre><p>协程的好处就是可以避免回调地狱，再来看一下golang的协程客户端</p><pre><code >package main\n\nimport (\n	\"fmt\"\n	\"io/ioutil\"\n	\"net/http\"\n	\"sync\"\n)\n\nfunc fetchURL(url string, wg *sync.WaitGroup) {\n	defer wg.Done()\n\n	resp, err := http.Get(url)\n	if err != nil {\n		fmt.Printf(\"Error fetching %s: %v\\n\", url, err)\n		return\n	}\n	defer resp.Body.Close()\n\n	body, err := ioutil.ReadAll(resp.Body)\n	if err != nil {\n		fmt.Printf(\"Error reading response body from %s: %v\\n\", url, err)\n		return\n	}\n\n	fmt.Printf(\"Response from %s: %d bytes\\n\", url, len(body))\n}\n\nfunc main() {\n	urls := []string{\n		\"https://www.example.com\",\n		\"https://www.google.com\",\n		\"https://www.github.com\",\n	}\n\n	var wg sync.WaitGroup\n\n	for _, url := range urls {\n		wg.Add(1)\n		go fetchURL(url, &wg)\n	}\n\n	wg.Wait()\n	fmt.Println(\"All requests completed.\")\n}</code></pre><p><br></p>', 'admin', '2025-01-22 23:41:04');

-- ----------------------------
-- Table structure for migrations
-- ----------------------------
DROP TABLE IF EXISTS `migrations`;
CREATE TABLE `migrations`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `migration` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `batch` int(11) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of migrations
-- ----------------------------

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `email_verified_at` timestamp NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `remember_token` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES (1, '岛屿可以找到海', '1234567@qq.com', NULL, '$2y$10$vOcKvtqUsWKcskQ6/DHv7.G174VQA5bEw686FXNZsp5jurDCfmxhi', 'SgvXvjufHZyKwvqSHy41DjEnbnZ8eWkcJkB5sE2Kbz0US4JYTl2uwtHoDVTy', '2025-01-19 04:51:34', '2025-01-22 15:05:48');

SET FOREIGN_KEY_CHECKS = 1;
